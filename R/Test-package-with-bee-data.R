library(readxl)
library(tidyverse)
library(dwctaxon)
library(taxize)
library(purrr)
library(tibble)

# load in excel files ----

ids <- read_xlsx(path = "2013 USDA Bee IDs.xlsx")

## convert to long data
id_list <- list()

for(i in 1:length(ids)){
  id_name <- stringr::str_to_lower(colnames(ids)[i])
  id_name_taxa <- stringr::str_remove(id_name, pattern = "\\s*\\(.*\\)[\\.{,3}\\d*]*")
  id_name_sex <- "not provided"
  if(stringr::str_detect(id_name_taxa,pattern = "male|female")){
    id_name_sex <- stringr::str_extract(string = id_name_taxa,pattern = "male|female")
    id_name_taxa <- stringr::str_remove_all(string =id_name_taxa,pattern = sprintf("\\s*%s\\s*",id_name_sex))
    id_name_sex <- stringr::str_to_lower(id_name_sex)
  }
  id_name_identifier_1 <- stringr::str_remove(id_name,pattern = sprintf("%s\\s",id_name_taxa))
  id_name_identifier_2 <- stringr::str_remove(id_name_identifier_1,pattern = id_name_sex)
  id_name_identifier_3 <- stringr::str_remove(id_name_identifier_2,pattern = "\\.{3}\\d+")
  id_name_identifier_no_parens <- stringr::str_remove_all(id_name_identifier_3,pattern = "\\(|\\)")
  ucmc_val <- ids[[i]]
  ucmc_val_no_nas <- ucmc_val[!is.na(ucmc_val)]
  ucmc_val_no_nas_fullucmc <- stringr::str_replace(string = ucmc_val_no_nas,pattern = "^CMC",replacement = "UCMC")
  ucmc_val_no_UCMC <- stringr::str_remove_all(ucmc_val_no_nas_fullucmc,pattern = "UCMC ")

  ucmc_val_no_UCMC_padded <- stringr::str_pad(trimws(ucmc_val_no_UCMC),width = 7,side = "left",pad = "0")


  df <- tibble( "UCMC_NUMBER" = trimws(ucmc_val_no_UCMC_padded),
                "TAXA" = trimws(id_name_taxa),
                "SEX" = trimws(id_name_sex),
                "IDENTIFIED_BY" = trimws(id_name_identifier_no_parens) )

  id_list[[i]] <- df
}

id_df <- do.call(rbind,id_list)



id_df_distinct <- id_df  %>%
  distinct(UCMC_NUMBER,.keep_all = TRUE)


# create dct dataset ----
taxa_data <- id_df_distinct %>%
  distinct(TAXA) %>%
  mutate(TAXA = stringr::str_to_sentence(TAXA)) %>%
  rename("scientificName" = "TAXA")

# check that names are properly formatted
sci_name_check <- dwctaxon::dct_check_sci_name(taxa_data,quiet = FALSE)

## check that auto fill functions work
taxa_data <-taxa_data %>%
  mutate(taxonomicStatus = "accepted")

tsn_ids <- taxize::get_tsn(sci_com = taxa_data$scientificName,searchtype = "scientific")
tax_not_found <- attributes(tsn_ids)$match == "not found"

taxa_data$scientificName[tax_not_found]

tsn_rank <- taxize::classification(tsn_ids,db = "itis")



tsn_rank_most_precise <- purrr::map_dfr(tsn_rank,function(x){
  df <- tibble(name = NA,
               rank = NA,
               id = NA)
  if(is.data.frame(x)){
    df <- tail(x,1)
  }
  return(df)
})



# test vignettes ----
dwc_data <- cbind(taxa_data,tsn_rank_most_precise)

dwc_data_terms <- dwc_data %>%
  rename("UCMC_name" = "scientificName") %>%
  rename("scientificName" = "name",
         "taxonRank" = "rank",
         "taxonID" = "id")

# start validation process

## add a row manually
## add honey bees and cemolobus

## I would like there to be a warning/message that taxon ids are autogenerated

dwc_data_add_row <- dwc_data_terms |>
  dct_add_row(
    scientificName = c("Apis mellifera", "Cemolobus ipomoeae"),
    taxonomicStatus = "accepted",
    taxonRank = "species"
  )


## add a dataframe

data_to_add <- tibble(scientificName = c("Agapostemon texanus","Agapostemon virescens"),
                      taxonomicStatus = "accepted",
                      taxonRank = "species")

dwc_data_add_df <- dwc_data_add_row %>%
  dct_add_row(new_dat = data_to_add)

### modify row

"Unlike add row, or add data frame, modify row rearranges the columns to a
different order. It will not add dct terms that are missing in the original
dataset."

dwc_data_add_df |>
  filter(!is.na(taxonID)) %>%
  dct_modify_row(
    taxonID = "5ac64c9b", # taxonID of Trichomanes crassum Copel.
    tax_status = "synonym",
   # acceptedNameUsageID = "72625a44" # won't add in the column automatically
  )

## add another term and test autocomplete

dwc_data_add_df$acceptedNameUsageID <- NA

dwc_data_mod_row <- dwc_data_add_df |>
  dct_add_row(
    taxonID = "fakeId0099", # fake taxonID
    tax_status = "synonym",
    acceptedNameUsageID = "5ac64c9b", # taxonID of Agapostemon virescens
    scientificName = "Agapostemon inventatus",
    taxonRank = "species"
  )

# check modifying a synonym updates other objects
dwc_data_mod_row_test <- dwc_data_mod_row %>%
  filter(!is.na(taxonID)) %>%
  dct_modify_row(
    taxonID = "5ac64c9b", # taxonID of Agapostemon texanus
    tax_status = "synonym",
    acceptedNameUsageID = "72625a44" # taxonID of Agapostemon virescens
    )

## Check the filling function

"This function does append new columns "
dwc_data_mod_fill_test <- dwc_data_mod_row_test %>%
  dct_fill_col(
    fill_to = "acceptedNameUsage",
    fill_from = "scientificName",
    match_to = "taxonID",
    match_from = "acceptedNameUsageID"
  )

tail(dwc_data_mod_fill_test)


"requires from column to a DWC term"
dwc_data_mod_fill_test_2 <- dwc_data_mod_row_test %>%
  dct_fill_col(
    fill_to = "acceptedNameUsage",
    fill_from = "nothing",
    match_to = "taxonID",
    match_from = "acceptedNameUsageID"
  )

"no warning/error if the from field doesnt exist"
dwc_data_mod_fill_test_3 <- dwc_data_mod_row_test %>%
  dct_fill_col(
    fill_to = "scientificName",
    fill_from = "acceptedNameUsage",
    match_to = "taxonID",
    match_from = "acceptedNameUsageID"
  )
tail(dwc_data_mod_fill_test_2)



## validate

dct_validate(dwc_data_mod_fill_test_3)

"found duplicate entries"
"did not mention non-dct terms"

# with summary param
dct_validate(dwc_data_mod_fill_test_3,on_fail = "summary")
"found bad column name"
"is there a row drop function?"


dwc_data_mod_fill_test_3 %>%
  dct_check_mapping(on_success = "logical")

